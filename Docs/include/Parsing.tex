% CREATED BY DAVID FRISK, 2016
\chapter{Parsing} \label{Parsing}

	Parsing is the process of analyzing the structure of a sequence of elements
	(called \emph{tokens}). This may simply consist of determining
	(\emph{recognizing}) whether a sequence conforms to a predefined structure
	(a \emph{grammar}), or to also create a description (\emph{parsing}) of how
	the sequence conforms (resulting in a \emph{parse tree}). For our
	purposes, the Context-free grammars describe the structures we are
	interested in:
	
	\begin{code}

		module grammar (N T : Set) where

		record CFG : Set where
		  constructor _;_;_
		  field
		    start : N
		    rules : (N × (N ∣ T)* )*
    		valid : (X : N) -> Σ λ α -> (X , α) ∈ rules

	\end{code}

	Here, type arguments \codett{N} and \codett{T} represent non-terminal and
	terminal symbols. Terminal symbols are used to represent instances of
	concrete tokens whereas non-terminal symbols are used as labels for more
	complex structures. Two examples: a grammar \codett{ S ; (S , r s ∷ ε) ∷ ε
	; \_ }, where \codett{S} is a non-terminal symbol and \codett{s} is a
	terminal symbol (and \codett{r} is the right side constructor for the
	optional type \codett{|}), will have a single conforming string, consisting
	of a single token \emph{'s'}. A grammar \codett{ S ; (S , r s ∷ l S ∷ ε) ∷
	(S , ε) ∷ ε ; \_ } will have conforming strings that either are empty, or
	start with the token \emph{'s'} followed by any sequence that conforms to
	the \codett{S} non-terminal. The set of conforming sequences for this second
	grammar is the set of (possibly empty) sequences only containing the token
	\emph{'s'}.

	A formal definition of when a list of tokens conforms to a grammar is also
	necessary:

	\begin{table}[h]
		\centering
		\begin{tabular}{cccc}
			 empty & concat & term & nonterm
		\end{tabular}
	\end{table}
	
	This may be expressed in Agda using the following data type:
	
	\begin{code}
	
		data _⊢_∈_ (G : CFG) :  T * -> (N ∣ T) * -> Set where
		  empty :
		    G ⊢ ε ∈ ε
		
		  concat : {u v : T *} {A : N} {α : (N ∣ T) *} ->
		    G ⊢ u ∈ l A ∷ ε -> G ⊢ v ∈ α -> G ⊢ u ++ v ∈ l A ∷ α
		
		  term : {u : T *} {a : T} {α : (N ∣ T) *} ->
		    G ⊢ u ∈ α -> G ⊢ a ∷ u ∈ r a ∷ α
		
		  nonterm : {A : N} {α : (N ∣ T) *} {u : T *} ->
		    (A , α) ∈ CFG.rules G -> G ⊢ u ∈ α -> G ⊢ u ∈ l A ∷ ε

	\end{code}

	Here, a judgment of the form \codett{G ⊢ u ∈ α} would mean that, given a
	grammar \codett{G} which gives semantics to non-terminals, the sequence of
	tokens \codett{u} conforms to the structure \codett{α}. That is, if
	\codett{A} is a non-terminal and \codett{a} is a terminal symbol, any value
	with the type \codett{G ⊢ l A ∷ ε ∈ a ∷ a ∷ ε} would constitute a proof
	that the sequence \codett{aa} does indeed conform to the structure
	\emph{"sequences that are equal to \codett{aa}"}.

	Another possible definition for conformance could be: 

	\begin{code}
	
		data _⊢_/_∈_ (G : CFG) : T * -> T * -> (N ∣ T)* -> Set where
		  empt : {w : T *} ->
		    G ⊢ w / w ∈ ε
		
		  conc : {u v w : T *} {X : N} {α : (N ∣ T) *} ->
		    G ⊢ u / v ∈ l X ∷ ε ->
		    G ⊢ v / w ∈ α ->
		      G ⊢ u / w ∈ l X ∷ α
		
		  term : {a : T} {u v : T *} {α : (N ∣ T) *} ->
		    G ⊢ u / v ∈ α ->
		      G ⊢ a ∷ u / v ∈ r a ∷ α
		
		  nont : {u v : T *} {X : N} {α : (N ∣ T) *} ->
		    CFG.rules G ∋ (X , α) ->
		    G ⊢ u / v ∈ α ->
		    G ⊢ u / v ∈ l X ∷ ε

	\end{code}

	Here, a judgment of the form \codett{G ⊢ v / w ∈ α} would mean that, given
	a grammar \codett{G}, the sequence \codett{v} up to, but not including
	\codett{w} conforms to the structure \codett{α}. This means \codett{w} will
	always be a suffix of \codett{v}. This definition, while very similar to
	the one above, has one advantage: the constructor \codett{conc} is not
	reliant on the list concatenation operator \codett{++}, while its
	counterpart \codett{concat} is. This can simplify proofs using this data
	type, as they will not be dependent on the normalization of the \codett{++}
	operator.

	This second data type can be constructed if the first one can:

	\begin{code}
	
		s : ∀ {u v w α G} ->
		  G ⊢ u / v ∈ α ->
		  G ⊢ u ++ w / v ++ w ∈ α
		s = {! ... !}
		
		sound₀ :  ∀ {G u α} ->
		  G ⊢ u ∈ α ->
		  G ⊢ u / ε ∈ α
		sound₀ empty = empt
		sound₀ (concat a b) = conc (s (sound₀ a)) (sound₀ b)
		sound₀ (term a) = term (sound₀ a)
		sound₀ (nonterm x a) = nont x (sound₀ a)

	\end{code}

	This proof is fairly simple: constructors \codett{empty}, \codett{term}, 
	and \codett{nonterm} match perfectly with their counterparts \codett{empt},
	\codett{term}, and \codett{nont}. \codett{concat} and \codett{conc} are 
	also almost identical, but require that we introduce some string 
	concatenation to the first argument.

	One problem with these data types is that it is possible to construct
	several different proofs for the same derivation of the same rule using the
	conc and empt rules:

	\begin{code}

		same-but-different : ∀ {u v X G} ->
		  G ⊢ u / v ∈ l X ∷ ε ->
		  G ⊢ u / v ∈ l X ∷ ε
		same-but-different g = conc g empt

	\end{code}

	This rule could be applied to the rule any number of times, and as such 
	judgments may not be equal even if they represent the same derivation of 
	the same rule. This will make it harder for us to reason about ambiguous 
	derivations, where the same structure can be derived from a sequence in 
	many different distinct ways. This problem is not present in the following 
	data structure.

	\begin{code}

		data _⊢_&_∈_ (G : CFG) : T * -> T * -> (N ∣ T)* -> Set where
		  empt : {w : T *} ->
		    G ⊢ w & w ∈ ε
		
		  conc : {u v w : T *} {X : N} {α β : (N ∣ T) *} ->
		    (X , α) ∈ CFG.rules G ->
		    G ⊢ u & v ∈ α ->
		    G ⊢ v & w ∈ β ->
		      G ⊢ u & w ∈ l X ∷ β
		
		  term : {a : T} {u v : T *} {α : (N ∣ T) *} ->
		    G ⊢ u & v ∈ α ->
		      G ⊢ a ∷ u & v ∈ r a ∷ α

	\end{code}

	This data structure merges the concatenation and nonterminal constructors, 
	so that concatenation can only be performed when introducing a new 
	non-terminal. This ensures that each constructor makes progress and 
	therefore prevents the problem above. This data structure is both sound and 
	complete with respect to the previous definitions.
	
	\begin{code}
	
	\end{code}
