% CREATED BY DAVID FRISK, 2016
\chapter{Parsing}

	Parsing is the process of analyzing the structure of a sequence of elements
	(called \emph{tokens}). This may simply consist of determining
	(\emph{recognizing}) whether a sequence conforms to a predefined structure
	(a \emph{grammar}), or to also create a description (\emph{parsing}) of how
	the sequence conforms (resulting in a \emph{parse tree}). For our
	purposes, the Context-free grammars describe the structures we are
	interested in:
	
	\begin{code}

		module grammar (N T : Set) where

		record CFG : Set where
		  constructor _;_;_
		  field
		    start : N
		    rules : (N × (N ∣ T)* )*
    		valid : (X : N) -> Σ λ α -> (X , α) ∈ rules

	\end{code}

	Here, type arguments \codett{N} and \codett{T} represent nonterminal and
	terminal symbols. Terminal symbols are used to represent instances of
	concrete tokens whereas nonterminal symbols are used as labels for more
	complex structures. Two examples: a grammar \codett{ S ; (S , r s ∷ ε) ∷ ε
	; \_ }, where \codett{S} is a nonterminal symbol and \codett{s} is a
	terminal symbol, will have a single conforming string, consisting of a
	single token \emph{'s'}. A grammar \codett{ S ; (S , r s ∷ l S ∷ ε) ∷ (S ,
	ε) ∷ ε ; \_ } will have conforming strings that either are empty, or start
	with the token \emph{'s'} followed by any sequence that conforms to the
	\codett{S} nonterminal. The set of conforming sequences for this second
	grammar is the set of (possibly empty) sequences only containing the token
	\emph{'s'}.

	A formal definition of when a list of tokens conforms to a grammar is also
	necessary:

	\begin{code}
	
		data _⊢_∈_ (G : CFG) :  T * -> (N ∣ T) * -> Set where
		  empty :
		    G ⊢ ε ∈ ε
		
		  concat : {u v : T *} {A : N} {α : (N ∣ T) *} ->
		    G ⊢ u ∈ l A ∷ ε -> G ⊢ v ∈ α -> G ⊢ u ++ v ∈ l A ∷ α
		
		  term : {u : T *} {a : T} {α : (N ∣ T) *} ->
		    G ⊢ u ∈ α -> G ⊢ a ∷ u ∈ r a ∷ α
		
		  nonterm : {A : N} {α : (N ∣ T) *} {u : T *} ->
		    (A , α) ∈ CFG.rules G -> G ⊢ u ∈ α -> G ⊢ u ∈ l A ∷ ε

	\end{code}

	Here, a judgment of the form \codett{G ⊢ u ∈ α} would mean that, given a
	grammar \codett{G} which gives semantics to nonterminals, the sequence of
	tokens \codett{u} conforms to the structure \codett{α}. That is, if
	\codett{A} is a nonterminal and \codett{a} is a terminal symbol, any value
	with the type \codett{G ⊢ l A ∷ ε ∈ a ∷ a ∷ ε} would constitute a proof
	that the sequence \codett{aa} does indeed conform to the structure
	\emph{"sequences that are equal to \codett{aa}"}.

	Another possible definition for conformance could be: 

	\begin{code}
	
		data _⊢_/_∈_ (G : CFG) : T * -> T * -> (N ∣ T)* -> Set where
		  empt : {w : T *} ->
		    G ⊢ w / w ∈ ε
		
		  conc : {u v w : T *} {X : N} {α : (N ∣ T) *} ->
		    G ⊢ u / v ∈ l X ∷ ε ->
		    G ⊢ v / w ∈ α ->
		      G ⊢ u / w ∈ l X ∷ α
		
		  term : {a : T} {u v : T *} {α : (N ∣ T) *} ->
		    G ⊢ u / v ∈ α ->
		      G ⊢ a ∷ u / v ∈ r a ∷ α
		
		  nont : {u v : T *} {X : N} {α : (N ∣ T) *} ->
		    CFG.rules G ∋ (X , α) ->
		    G ⊢ u / v ∈ α ->
		    G ⊢ u / v ∈ l X ∷ ε

	\end{code}

	Here, a judgment of the form \codett{G ⊢ v / w ∈ α} would mean that, given
	a grammar \codett{G}, the sequence \codett{v} up to, but not including 
	\codett{w} conforms to the structure \codett{α}. This means \codett{w} will
	always be a suffix of \codett{v}.

	These definitions are, in fact, equivalent:

	\begin{code}
	
	\end{code}
