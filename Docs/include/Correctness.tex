
\chapter{Correctness proofs}

	Here, we discuss the structure of the correctness proofs for the
	implementation discussed in chapter \ref{Earleys}. First, we discuss
	soundness of the generated item sets, and continue from there to their
	completeness. Finally backtracking from the item sets to create parse
	trees, and ambiguous parses, which are of particular interest for the
	Earley parsing algorithm, are discussed.

	\section{Soundness}

		The soundness proof for our implementation is straightforward
		throughout. First, we provide a definition of sound items sets:

		\begin{code}
			Valid : ∀ {w v} -> Item w v -> Set
			Valid {w} {v} i = G ⊢ Item.u i / v ⟶* Item.Y i / Item.β i

			Sound : ∀ {w v} -> WSet w v -> Set
			Sound (start rs) = ∀ {i} -> i ∈ rs -> Valid i
			Sound (step ω rs) = Sound ω × (∀ {i} -> i ∈ rs -> Valid i)

			H : ∀ {v w} {ω : WSet w v} -> Sound ω -> (∀ {i} -> i ∈ Sₙ ω -> Valid i)
			H {ω = start rs} s = s
			H {ω = step ω rs} s = snd s
		\end{code}

		An item is \codett{Valid} if it can be derived using the Earley rules,
		and a set of item sets is \codett{Sound} if all items in it are valid.
		This definition of soundness is both simple and intuitive. Proving that
		the implementation always preserves these properties is also very
		straightforward, as the algorithm never modifies items that are added
		to an item set, and the implementation generates new items in three
		different ways, matching the \emph{scan}, \emph{predict}, and
		\emph{complete} steps in the algorithm also present in our Earley
		propositions.

		First, we will take a look at the scanning step. We will consider
		\codett{scanr₀} to be sound if all its generated items are valid, given
		valid input. This allows us to show that \codett{scanr} preserves
		soundness for \codett{WSet}s:

		\begin{code}
			sound-scanr₀ : ∀ {a v w} -> ∀ rs ->
			  (∀ {i} -> i ∈ rs -> Valid i) ->
			  (∀ {i} -> i ∈ scanr₀ {w} {v} a rs -> Valid i)

			sound-scanr₀ ε f ()

			sound-scanr₀ ((X ∘ u ↦ α ∘ ε) ∷ rs) f p = 
			  sound-scanr₀ rs (f ∘ in-tail) p

			sound-scanr₀ ((X ∘ u ↦ α ∘ l Y ∷ β) ∷ rs) f p = 
			  sound-scanr₀ rs (f ∘ in-tail) p

			sound-scanr₀ {a} ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) f p with decidₜ a b
			... | no x = sound-scanr₀ rs (f ∘ in-tail) p
			... | yes refl with p
			...            | in-head    = scanner (f in-head)
			...            | in-tail p₁ = sound-scanr₀ rs (f ∘ in-tail) p₁

			sound-scanr : ∀ {a w v} -> (ω : WSet w (a ∷ v)) ->
			  Sound ω -> Sound (scanr a ω)
			sound-scanr (start rs) s = s , sound-scanr₀ rs s
			sound-scanr (step w rs) (s , s₁) = s , s₁ , sound-scanr₀ rs s₁
		\end{code}

		The structure of the proof matches the structure of the original
		definitions closely, due to the way normalizaitons are axiomatic to the
		type system. If there is no input, there is no output, so nothing
		needs to be shown. Even when there is, \codett{scanr₀} only generates
		new items from items that expect a terminal, and only does so when that
		terminal equals the next token in the input sequence. Finally, the
		proof is structured so that an arbitrary generated item is chosen, and
		that item should then be shown to be valid. The argument \codett{p}
		specifies for which of the generated items the proof is desired, and if
		the one generated at this recursion level is not the correct one, we
		must continue the proof search.

		Next, we continue in a similar fashion for the complete step:

		\begin{code}
			sound-compl₀ : ∀ {u v w} (w : WSet w v) ->
			  Sound w -> (∀ {i} -> i ∈ compl₀ {u} {v} w -> Valid i)
			sound-compl₀ {u} {v} w s p           with eq-T* u v
			sound-compl₀ {v} {v} w s p           | yes refl = H s p
			sound-compl₀ {u} {v} (start rs) s () | no x
			sound-compl₀ {u} {v} (step w rs) s p | no x = sound-compl₀ w (fst s) p
		\end{code}

		As \codett{sound-compl₀} is nothing more than a lookup function to find
		the correct item set to use from a \codett{WSet}, its soundness is
		trivial when the soundness of the original item set is given.
		\codett{sound-compl₁} is more interesting:

		\begin{code}
			sound-compl₁ : ∀ {u v w} ->
			  (i : Item w v) ->
			  (p : Item.β i ≡ ε) ->
			  (q : Item.u i ≡ u) ->
			  (rs : Item w u *) ->
			  Valid i -> (∀ {j} -> j ∈ rs -> Valid j) ->
			  (∀ {j} -> j ∈ compl₁ i p rs -> Valid j)

			sound-compl₁ i refl refl ε v f ()

			sound-compl₁ i refl refl ((Y ∘ u₁ ↦ α₁ ∘ ε) ∷ rs) v f q =
			  sound-compl₁ i refl refl rs v (f ∘ in-tail) q

			sound-compl₁ i refl refl ((Y ∘ u₁ ↦ α₁ ∘ r a ∷ β) ∷ rs) v f q =
			  sound-compl₁ i refl refl rs v (f ∘ in-tail) q

			sound-compl₁ i refl refl ((Y ∘ u₁ ↦ α₁ ∘ l Z ∷ β) ∷ rs) v f q with decidₙ X Z
			... | no x = sound-compl₁ i refl refl rs v (f ∘ in-tail) q
			... | yes refl with q = complet (f in-head) v
			...            | in-head     = complet (f in-head) v
			...            | (in-tail q) = sound-compl₁ i refl refl rs v (f ∘ in-tail) q
		\end{code}

		Here, we show, given a valid item that can be completed ($\beta =
		\epsilon$), and an item set from which matching completion items can be
		found, that \codett{compl₁} only generates valid items if all input
		items are valid. Like with the scanning step, we only need to focus on
		the cases where items are actually generated, and when they are, if the
		current one is the one for which a proof is sought. The generated items
		also match the \emph{complete} step of our Earley proposition
		perfectly, so the proof for the relevant item is also very simple.

		The soundness proof for \codett{sound-compl₂} is then trivial:

		\begin{code}
			sound-compl₂ : ∀ {v w} ->
			  (i : Item w v) ->
			  (p : Item.β i ≡ ε) ->
			  Valid i -> (ω : WSet w v) -> Sound ω ->
			  (∀ {j} -> j ∈ compl₂ i p ω -> Valid j)
			sound-compl₂ i p v ω s q =
			  sound-compl₁ i p refl (compl₀ ω) v (sound-compl₀ ω s) q
		\end{code}

		As \codett{predict₁} works in very much the same way as
		\codett{compl₂}, both their type proof structure are very similar (the
		only difference being that \codett{compl₂} requires $\beta$ to start
		with a non-terminal instead of being empty), and so the soundness proof
		for \codett{predict₁} will not be discussed in further detail.

		Soundness of the merged step \codett{pred-comp} of the \codett{predict}
		and \codett{compl} steps is also completely trivial, as there are no
		modification to existing items nor generation of new ones except for
		what is done in \codett{compl₂} and \codett{predict₁}. Their type
		signatures are shown below:

		\begin{code}
			sound-pred-comp₀ : ∀ {v w} ->
			  (i : Item w v) ->
			  (w : WSet w v) ->
			  Valid i -> Sound w ->
			  (∀ {j} -> j ∈ Σ.proj₁ (pred-comp₀ i w) -> Valid j)

			sound-pred-comp₁ : ∀ {w v} (ω : WSet w v) -> ∀ ss rs ->
			  (∀ {i} -> i ∈ ss -> Valid i) ->
			  (∀ {i} -> i ∈ rs -> Valid i) ->
			  Sound ω -> (∀ {i} -> i ∈ pred-comp₁ ω ss rs -> Valid i)
		\end{code}

		\codett{sound-pred-comp₂} looks a bit more complex:

		\begin{code}
			sound-pred-comp₂ : ∀ {w v} (ω : WSet w v) -> ∀ ss rs m p q ->
			  (∀ {i} -> i ∈ ss -> Valid i) ->
			  (∀ {i} -> i ∈ rs -> Valid i) ->
			  Sound ω -> Sound (pred-comp₂ ω ss rs m p q)
			sound-pred-comp₂ ω ss rs zero () q f g s
			sound-pred-comp₂ ω ss ε (suc m) p q f g s = soundₙ ω f s
			sound-pred-comp₂ ω ss rs@(r₁ ∷ _) (suc m) p q f g s =
			  let x₁ = pred-comp₁ ω ss rs in
			  let x₂ = x₁ \\ (rs ++ ss) in
			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q  in
			  let p₂ = wf-pcw₂ x₁ (rs ++ ss) q in
			  let p₃ = sound-pred-comp₁ ω ss rs f g s in
			  let p₄ = s-pcw₀ Valid p₃ in
			  sound-pred-comp₂ ω (rs ++ ss) x₂ m p₁ p₂ (in-either Valid g f) p₄ s
		\end{code}

		Fortunately, most of the apparent complexity of this function is caused
		by the termination bounds, which do not directly affect soundness. As
		items are still not modified, we need only to show that the items in
		the item sets after concatenation and de-duplication are indeed the
		same items as they were before, and that all newly generated items are
		\codett{Valid}. The final steps of the parser can be shown to preserve
		sound in the same way:

		\begin{code}
			sound-pred-comp : ∀ {w v} {ω : WSet w v} ->
			  Sound ω -> Sound (pred-comp ω)

			sound-step₀ : ∀ {w a v} {ω : WSet w (a ∷ v)} ->
			  Sound ω -> Sound (step₀ ω)

			sound-parse₀ : ∀ {w v} -> {ω : WSet w v} ->
			  Sound ω -> Sound (parse₀ ω)

			sound-parse : ∀ w -> Sound (parse w)
		\end{code}

		Which concludes the soundness proof for our Earley implementation.

	\section{Completeness}

		The completeness proof is significantly more lengthy than the soundness
		proof. This is caused by the fact that while soundness is a very
		'local' property, dealing only with individual items, completeness is
		much more global in nature, dealing with the entire item sets. This
		means all operations that could previously be glanced over will now
		require much more extensive analysis.

		We will begin with a definition of completeness for item sets:

		\begin{code}
			_≋_ : ∀ {t u v X α β} -> Item t v -> G ∙ t ⊢ u / v ⟶* X / α ∙ β -> Set
			_≋_ {t} {u} {v} {X} {α} {β} i g =
				(Item.Y i , Item.u i , Item.α i , Item.β i) ≡ (X , u , α , β)

			Complete₀ : ∀ {t v} -> Item t v * -> Set
			Complete₀ {t} {v} rs = ∀ {u Y α β} ->
			  (i : Item t v) ->
			  (g : G ∙ t ⊢ u / v ⟶* Y / α ∙ β) ->
			  i ≋ g ->
			  i ∈ rs
		\end{code}

		First a bit of notation: we use \codett{i ≋ g} to mean that an item $i$
		is equal to the item that should be present in the item set given the
		Earley proposition $g$ defined earlier in this chapter. A set of items
		that represent partial parses of an input string $t$ before parsing
		remainder $v$ is then considered complete if any items that represent
		any possible Earley state in the item set between the last element of
		$t$ and the first of $u$ is present in the set. This is a 'shallow'
		definition of completeness: only the topmost item set is considered,
		and all prevous ones discarded. We also define two 'deeper' notions of
		completeness for \codett{WSet}s:

		\begin{code}
			mutual
			  Complete : ∀ {v w} -> WSet w v -> Set
			  Complete ω = Complete₀ (Sₙ ω) × Complete* ω

			  Complete* : ∀ {v w} -> WSet w v -> Set
			  Complete* (start rs) = ⊤
			  Complete* (step ω rs) = Complete ω
		\end{code}

		Here, the \codett{Complete*} property for a \codett{WSet} would mean
		that all item sets, except for the very topmost one, are complete, and
		\codett{Complete} is completeness for \codett{WSet}s: all prevous item
		sets are complete, as is the topmost one.

		We start by taking a fairly high-level overview of the completeness
		proof which we will do by induction on the Earley propositions. The
		type for this induction is fairly lengthy, so we will break it up into
		several peices and discuss them separately:

		\begin{code}
			complete-ind : ∀ {t v a} ->
			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
			  {P : Item t v -> Set} ->

			  (∀ {u X α β} ->
			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
			    (i : Item t v) -> (i ≋ scanner g) ->
			    P i
			  ) ->

			  (∀ {β} ->
			    (z : t ≡ v) ->
			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
			    (i : Item v v) ->
			    i ≋ initial x -> eq-prop P i z
			  ) ->
		\end{code}

		To begin with, the original input string $t$, and its current remainder
		$v$ are given as implicit arguments, but together with these we also
		provide a single token that will be used to name the last scanned
		token, together with a proof that this actually was the previous token.
		The requirement of this token as an argument restricts this proof to
		only be valid for parsing alphabets that have at least one token, but
		as token-free parsing is completely trivial we did not feel compelled
		to remove this restriction. This previous token is used in the first
		function argument, which represents an assumption that the property
		\codett{P} holds for all items that can be generated from the scanning
		step. The second argument represents the same assumption, but for the
		initial items. This will only be relevant when we are considering the
		very first item set, which is why \codett{t ≡ v}. Here,
		\codett{eq-prop} is only present because of the slight mismatch of
		types between the initial items and \codett{P} caused by this equality
		constraint. At this time, we do not need to bother with what specific
		proposition we will use this function to prove, which is why it is 
		parameterized on the proposition \codett{P}.

		Continuing on, we have:

		\begin{code}
			  (∀ {u X Y α β δ} (x : (Y , δ) ∈ CFG.rules G) ->
			    (i j : Item t v) ->
			    (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
			    (i ≋ g) -> P i ->
			    (j ≋ predict x g) -> P j
			  ) ->

			  (∀ {u w X Y α β γ} ->
			    (j k : Item t v) ->
			    (g : G ∙ t ⊢ u / w ⟶* X / α ∙ l Y ∷ β) ->
			    (h : G ∙ t ⊢ w / v ⟶* Y / γ ∙ ε) ->
			    (j ≋ h) -> P j ->
			    (k ≋ complet g h) -> P k
			  ) ->
		\end{code}

		These arguments fill the same function as the previous two, but for 
		items that can be generated via the predict and complete steps, 
		repspectively. While their function as part of the induction step is 
		equivalent to that of the two previous arguments, when making use of 
		this induction step these will represent the main reasoning of the 
		proof.
		
		\begin{code}
			  (∀ {u X α β} ->
			    (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
			    (i : Item t v) ->
			    i ≋ g ->
			    P i
			  )

			complete-ind s f ini h c (initial x) i refl =
			  ini refl x i refl
			
			complete-ind {a} s f ini h c (scanner g) i p =
			  case test₀ s g of λ {refl -> f g i p}
			
			complete-ind s f ini h c (predict x g) i p =
			  let x₁ = complete-ind s f ini h c g _ refl in
			  h x (_ ∘ _ ↦ _ ∘ _ [ in-g g ∘ suff-g₁ g ]) i g refl x₁ p
			
			complete-ind s f ini h c (complet g g₁) i p =
			  let x₁ = complete-ind s f ini h c g₁ _ refl in
			  c (_ ∘ _ ↦ _ ∘ _ [ in-g g₁ ∘ suff-g₂ g ]) i g g₁ refl x₁ p
		\end{code}

		Given that the proposition holds for all ways of counstructing items in
		ways that satisfy the Earley rules discuss in chapter \ref{Earleys}, it
		will hold for all items that can be constructed using these rules. The
		proof is straightforward, but unfortunately, while the compiler can
		automatically infer the item needed in the recursion, it is unable to 
		infer it's $\chi$ and $\psi$ values. Fortunately, these can be 
		recunstructed from the Earley rules.

		\begin{code}
			complete₁-pred-comp₂ : ∀ {t v} -> ∀ ss rs m p q ->
			  (ω : WSet t v) ->
			  Nx ss rs ->
			  ∀ {u X Y α β δ}
			  (x : (Y , δ) ∈ CFG.rules G) ->
			  (i j : Item t v) ->
			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
			  i ≋ g ->
			  i ∈ Sₙ (pred-comp₂ ω ss rs m p q) ->
			  j ≋ predict x g ->
			    j ∈ Sₙ (pred-comp₂ ω ss rs m p q)
			complete₁-pred-comp₂ ss rs            zero    () q ω           nx x i j g z₁ z₂ z₃
			complete₁-pred-comp₂ ss ε             (suc m) p  q (start rs)  nx x i j g z₁ z₂ z₃ =
			  nx x i j g z₁ z₂ z₃
			complete₁-pred-comp₂ ss ε             (suc m) p  q (step ω rs) nx x i j g z₁ z₂ z₃ =
			  nx x i j g z₁ z₂ z₃
			complete₁-pred-comp₂ ss rs@(r₁ ∷ rs₀) (suc m) p  q ω           nx x i j g z₁ z₂ z₃ =
			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q in
			  let q₁ = wf-pcw₂ (pred-comp₁ ω ss rs) (rs ++ ss) q in
			  complete₁-pred-comp₂ (rs ++ ss) _ m p₁ q₁ ω (nx' ω nx) x i j g z₁ z₂ z₃
		\end{code}

		\begin{code}
			complete₂-pred-comp₂ : ∀ {t v} -> ∀ ss rs m p q ->
			  (ω : WSet t v) ->
			  Complete* ω ->
			  Nx₂ ss rs ->
			  ∀ {u w X Y α β γ}
			  (j k : Item t v) ->
			  (g : G ∙ t ⊢ u / w ⟶* X / α ∙ l Y ∷ β) ->
			  (h : G ∙ t ⊢ w / v ⟶* Y / γ ∙ ε) ->
			  j ≋ h -> j ∈ Sₙ (pred-comp₂ ω ss rs m p q) ->
			  k ≋ complet g h ->
			    k ∈ Sₙ (pred-comp₂ ω ss rs m p q)
			complete₂-pred-comp₂ ss rs            zero    () q ω           c nx x i j g z₁ z₂ z₃
			complete₂-pred-comp₂ ss ε             (suc m) p  q (start rs)  c nx x i j g z₁ z₂ z₃ =
			  nx x i j g z₁ z₂ z₃
			complete₂-pred-comp₂ ss ε             (suc m) p  q (step ω rs) c nx x i j g z₁ z₂ z₃ =
			  nx x i j g z₁ z₂ z₃
			complete₂-pred-comp₂ ss rs@(r₁ ∷ rs₀) (suc m) p  q ω           c nx x i j g z₁ z₂ z₃ =
			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q in
			  let q₁ = wf-pcw₂ (pred-comp₁ ω ss rs) (rs ++ ss) q in
			  complete₂-pred-comp₂ (rs ++ ss) _ m p₁ q₁ ω c (nx₂' ω c nx) x i j g z₁ z₂ z₃
		\end{code}

		\begin{code}
			complete-scanner : ∀ {t u v X α β} -> ∀ a ->
			  (ω : WSet t (a ∷ v)) ->
			  Complete ω ->
			  (i : Item t (a ∷ v)) ->
			  (j : Item t v) ->
			  (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
			  i ≋ g ->
			  j ≋ scanner g ->
			    j ∈ Sₙ (scanner a ω)
		\end{code}

		\begin{code}
			complete-itemize : ∀ w {β} ->
			  (x : (CFG.start G , β) ∈ CFG.rules G) ->
			  (i : Item w w) ->
			  i ≋ initial x ->
			    i ∈ itemize w (lookup (CFG.start G) (CFG.rules G))
		\end{code}

%		\begin{code}
%			complete-predict₀ : ∀ {t u v X Y α β δ} ->
%			  (ψ₀ : Σ λ s -> s ++ v ≡ t) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ v / v ⟶* Y / ε ∙ δ) ->
%			  (p : i ≋ g) ->
%			  (q : j ≋ h) ->
%			  (rs : (Σ λ t -> (t ∈ CFG.rules G) × (fst t ≡ Y)) *) ->
%			  (Σ λ e -> σ (Y , δ) e ∈ rs) ->
%			  j ∈ predict₀ ψ₀ i (≋-β i g p) rs
%			complete-predict₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl ε (σ p₁ ())
%			complete-predict₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , γ) (p , refl) ∷ rs) q with eq-α γ δ
%			complete-predict₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , δ) (p , refl) ∷ rs) q | yes refl = in-head
%			complete-predict₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , δ) (p , refl) ∷ rs) (σ (q , refl) in-head) | no x = void (x refl)
%			complete-predict₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , γ) (p , refl) ∷ rs) (σ q₁ (in-tail q₀)) | no x =
%			  in-tail (complete-predict₀ ψ₀ _ _ g h refl refl rs (σ q₁ q₀))
%
%			complete-predict₁ : ∀ {t u v X Y α β δ} ->
%			  (ω : WSet t v) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  (x : CFG.rules G ∋ (Y , δ)) ->
%			  (p : i ≋ g) ->
%			  j ≋ predict x g ->
%			  j ∈ predict₁ i (≋-β i g p) ω
%			complete-predict₁ ω i@(X ∘ u ↦ α ∘ l Y ∷ β) j g x refl q =
%			  complete-predict₀ _ i j g (predict x g) refl q (lookup Y (CFG.rules G)) (lookup-sound x)
%
%			complete-deduplicate : ∀ {w v i} -> (as : Item w v *) -> i ∈ as -> i ∈ Σ.proj₁ (deduplicate as)
%			complete-deduplicate ε ()
%			complete-deduplicate (x ∷ as) p with elem eq-item x (Σ.proj₁ (deduplicate as))
%			complete-deduplicate (x ∷ as) in-head     | yes x₁ = x₁
%			complete-deduplicate (x ∷ as) (in-tail p) | yes x₁ = complete-deduplicate as p
%			complete-deduplicate (x ∷ as) in-head     | no x₁ = in-head
%			complete-deduplicate (x ∷ as) (in-tail p) | no x₁ = in-tail (complete-deduplicate as p)
%
%			complete₁-pred-comp₀ : ∀ {t u v X Y α β δ} ->
%			  (ω : WSet t v) ->
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g ->
%			  j ≋ predict x g ->
%			    j ∈ Σ.proj₁ (pred-comp₀ i ω)
%			complete₁-pred-comp₀ ω x i@(Y ∘ u ↦ α ∘ l Z ∷ β) j@(Z ∘ u₁ ↦ ε ∘ β₁ [ χ₁ ∘ ψ₁ ]) g refl refl =
%			  let x₁ = complete-predict₁ ω i j g x refl refl in
%			  complete-deduplicate (predict₁ i refl ω) x₁
%
%			complete₂-pred-comp₀ : ∀ {t u v w X Y α β γ} ->
%			  (ω : WSet t w) ->
%			  (i j : Item t w) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ v / w ⟶* Y / γ ∙ ε) ->
%			  i ≋ h ->
%			  j ≋ complet g h ->
%			    j ∈ Σ.proj₁ (pred-comp₀ i ω)
%			complete₂-pred-comp₀ ω i j g h refl refl =
%			  complete-deduplicate (complete₂ i refl ω) {!!}
%
%			complete₁-pred-comp₁ : ∀ {t u v X Y α β δ ss} -> ∀ rs ->
%			  (ω : WSet t v)
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g ->
%			  i ∈ rs ->
%			  j ≋ predict x g ->
%			    j ∈ pred-comp₁ ω ss rs
%			complete₁-pred-comp₁ {ss = ss} (i  ∷ rs) ω x i j g o in-head q =
%			  in-l (complete₁-pred-comp₀ (Wₙ ω ss) x i j g o q)
%			complete₁-pred-comp₁ (r₁ ∷ rs) ω x i j g o (in-tail p) q =
%			  in-r (complete₁-pred-comp₁ rs ω x i j g o p q)
%
%			complete₁₀-pred-comp₂ : ∀ {t v ss rs m p q} ->
%			  (ω : WSet t v) ->
%			  (i : Item t v) ->
%			  i ∈ ss ->
%			  i ∈ Sₙ (pred-comp₂ ω ss rs m p q)
%			complete₁₀-pred-comp₂ {ss = ss} {rs} {zero} {()} ω i s
%			complete₁₀-pred-comp₂ {ss = ss} {ε} {suc m} {p} (start rs) i s = s
%			complete₁₀-pred-comp₂ {ss = ss} {ε} {suc m} {p} (step ω rs) i s = s
%			complete₁₀-pred-comp₂ {ss = ss} {rs@(_ ∷ _)} {suc m} {p} {q} ω i s =
%			  complete₁₀-pred-comp₂ {m = m} ω i (in-r s)
%
%			complete₁₁-pred-comp₂ : ∀ {t v ss rs m p q} ->
%			  (ω : WSet t v) ->
%			  (i : Item t v) ->
%			  i ∈ rs ->
%			  i ∈ Sₙ (pred-comp₂ ω ss rs m p q)
%			complete₁₁-pred-comp₂ {ss = ss} {rs} {zero} {()} ω i s
%			complete₁₁-pred-comp₂ {ss = ss} {ε} {suc m} {p} ω i ()
%			complete₁₁-pred-comp₂ {ss = ss} {rs@(_ ∷ _)} {suc m} {p} ω i s =
%			  complete₁₀-pred-comp₂ {m = m} ω i (in-l s)
%
%			complete₁₂-pred-comp₂ : ∀ {t v ss rs m p q} ->
%			  (ω : WSet t v) ->
%			  ∀ {u X Y α β δ} ->
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> i ∈ rs ->
%			  j ≋ predict x g -> j ∈ Sₙ (pred-comp₂ ω ss rs m p q)
%			complete₁₂-pred-comp₂ {ss = ss} {rs} {zero} {p = ()} ω x i j g p p' q
%			complete₁₂-pred-comp₂ {ss = ss} {ε} {suc m} ω x i j g p () q
%			complete₁₂-pred-comp₂ {ss = ss} {rs@(_ ∷ _)} {suc m} ω x i j g p p' q =
%			  let x₁ = pred-comp₁ ω ss rs in
%			  let x₂ = x₁ \\ (rs ++ ss) in
%			  let y₁ = complete₁-pred-comp₁ rs ω x i j g p p' q in
%			  let y₂ = include-\\ {as = x₁} {bs = rs ++ ss} y₁ in
%			  case in-lr x₂ (rs ++ ss) y₂ of
%			    λ { (r z) → complete₁₀-pred-comp₂ {m = m} ω j z
%			      ; (l z) → complete₁₁-pred-comp₂ {m = m} ω j z
%			      }
%
%			Nx : ∀ {t v} -> Item t v * -> Item t v * -> Set
%			Nx {t} {v} ss rs =
%			  ∀ {u X Y α β δ} ->
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> i ∈ ss ->
%			  j ≋ predict x g ->
%			    j ∈ (rs ++ ss)
%
%			nx' : ∀ {t v rs ss} (ω : WSet t v) ->
%			  Nx ss rs ->
%			  Nx (rs ++ ss) (pred-comp₁ ω ss rs \\ (rs ++ ss))
%			nx' {rs = ε} {ss} ω nx x i j g z₁ z₂ z₃ = nx x i j g z₁ z₂ z₃
%			nx' {rs = rs@(r₁ ∷ rs₀)} {ss} ω nx x i j g z₁ z₂ z₃ =
%			  case in-lr rs ss z₂ of
%			    λ { (r x₁) →
%			      let x₁ = nx x i j g z₁ x₁ z₃  in
%			      in-r x₁
%			    ; (l x₁) →
%			      let y₁ = complete₁-pred-comp₁ rs ω x i j g z₁ x₁ z₃ in
%			      include-\\ y₁
%			    }
%
%			Nx₂ : ∀ {t v} -> Item t v * -> Item t v * -> Set
%			Nx₂ {t} {v} ss rs =
%			  ∀ {u w X Y α β γ} ->
%			  (j k : Item t v) ->
%			  (g : G ∙ t ⊢ u / w ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ w / v ⟶* Y / γ ∙ ε) ->
%			  j ≋ h -> j ∈ ss ->
%			  k ≋ complet g h ->
%			    k ∈ (rs ++ ss)
%
%			nx₂' : ∀ {t v rs ss} (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx₂ ss rs ->
%			  Nx₂ (rs ++ ss) (pred-comp₁ ω ss rs \\ (rs ++ ss))
%			nx₂' {rs = ε} {ss} ω c nx x i j g z₁ z₂ z₃ = nx x i j g z₁ z₂ z₃
%			nx₂' {rs = rs@(r₁ ∷ rs₀)} {ss} ω c nx x i j g z₁ z₂ z₃ =
%			  case in-lr rs ss z₂ of
%			    λ { (r x₁) →
%			      let x₁ = nx x i j g z₁ x₁ z₃  in
%			      in-r x₁
%			    ; (l x₁) → {!!}
%			    }
%
%			complete-pred-comp₂ : ∀ {a t v ss rs m p q} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx ss rs ->
%			  Nx₂ ss rs ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ (pred-comp₂ ω ss rs m p q)
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (λ i -> i ∈ Sₙ (pred-comp₂ ω ss rs m p q)) i z
%			  ) ->
%			  ∀ {u X α β} ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			  (i : Item t v) ->
%			  i ≋ g -> i ∈ Sₙ (pred-comp₂ ω ss rs m p q)
%			complete-pred-comp₂ {a} {t} {v} {ss} {rs} {m} {p} {q} h ω c nx nx₂ s u g i e =
%			  test {P = λ i -> i ∈ Sₙ (pred-comp₂ ω ss rs m p q)}
%			    h
%			    s
%			    u
%			    (complete₁-pred-comp₂ ss rs m p q ω nx)
%			    (complete₂-pred-comp₂ ss rs m p q ω c nx₂)
%			    g i e
%
%			complete₀-pred-comp : ∀ {a t v} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx ε (Σ.proj₁ (deduplicate (Sₙ ω))) ->
%			  Nx₂ ε (Σ.proj₁ (deduplicate (Sₙ ω))) ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ (Σ.proj₁ (deduplicate (Sₙ ω)))
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (_∈ Σ.proj₁ (deduplicate (Sₙ ω))) i z
%			  ) ->
%			  ∀ {u X α β} ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			  (i : Item t v) ->
%			  i ≋ g -> i ∈ Sₙ (pred-comp ω)
%			complete₀-pred-comp {a} {t} s ω c nx nx₂ fx fx₂ g i p =
%			  let x₁ = deduplicate (Sₙ ω) in
%			  let x₂ = (unique-++ (Σ.proj₁ x₁) ε (Σ.proj₀ x₁) u-ε λ ()) in
%			  complete-pred-comp₂ {p = ≤ₛ (≤-self _)} {q = x₂} s ω c nx nx₂
%			    (λ g₁ i₁ x → complete₁₁-pred-comp₂ {p = ≤ₛ (≤-self _)} {q = x₂} ω i₁ (fx g₁ i₁ x))
%			    (λ {refl x i₁ x₃ → complete₁₁-pred-comp₂ {p = ≤ₛ (≤-self _)} {q = x₂} ω i₁ (fx₂ refl x i₁ x₃)})
%			    g i p
%
%			complete₃-pred-comp₂ : ∀ {t v} -> ∀ ss rs m p q ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Complete* (pred-comp₂ ω ss rs m p q)
%			complete₃-pred-comp₂ ss rs zero () q ω c
%			complete₃-pred-comp₂ ss ε (suc m) p q (start rs) c = top
%			complete₃-pred-comp₂ ss ε (suc m) p q (step ω rs) c = c
%			complete₃-pred-comp₂ ss rs@(_ ∷ _) (suc m) p q ω c =
%			  let x₁ = pred-comp₁ ω ss rs in
%			  let x₂ = x₁ \\ (rs ++ ss) in
%			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q in
%			  let q₁ = wf-pcw₂ x₁ (rs ++ ss) q in
%			  complete₃-pred-comp₂ (rs ++ ss) x₂ m p₁ q₁ ω c
%
%			complete₁-pred-comp : ∀ {t v} ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Complete* (pred-comp ω)
%			complete₁-pred-comp ω =
%			  let x₁ = deduplicate (Sₙ ω) in
%			  let x₂ = (unique-++ (Σ.proj₁ x₁) ε (Σ.proj₀ x₁) u-ε λ ()) in
%			  complete₃-pred-comp₂ ε _ _ (≤ₛ (≤-self _)) x₂ ω
%
%			complete₂-pred-comp : ∀ {t v} ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			    (i : Item t v) ->
%			    i ≋ g -> i ∈ Sₙ (pred-comp ω)
%			  ) ->
%			  Complete (pred-comp ω)
%			complete₂-pred-comp ω c f = (λ i g x → f g i x) , complete₁-pred-comp ω c
%
%			complete-pred-comp : ∀ {a t v} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  Complete (pred-comp ω)
%			complete-pred-comp {a} {t} s ω c fx fx₂ =
%			  let
%			    x₅ = complete₀-pred-comp s ω c (λ x i j g x₁ ()) (λ j k g h x ())
%			      (λ {g i x → complete-deduplicate (Sₙ ω) (fx g i x)})
%			      λ {refl x i x₁ → complete-deduplicate (Sₙ ω) (fx₂ refl x i x₁)}
%			  in
%			  complete₂-pred-comp ω c x₅
%
%			complete-step : ∀ {a₀ a t v} ->
%			  (Σ λ u -> u ++ (a₀ ∷ a ∷ v) ≡ t) ∣ (a ∷ v) ≡ t ->
%			  (ω : WSet t (a ∷ v)) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a₀ ∷ a ∷ v ⟶* X / α ∙ r a₀ ∷ β) ->
%			    (i : Item t (a ∷ v)) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ a ∷ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item (a ∷ v) (a ∷ v)) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  ∀ {u X α β} ->
%			  (i : Item t (a ∷ v)) ->
%			  (j : Item t v) ->
%			  (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			  i ≋ g ->
%			  j ≋ scanner g ->
%			    j ∈ Sₙ (step ω)
%			complete-step {a₀} {a} s ω c fx fx₂ i j g refl refl =
%			  let
%			    x₁ = complete-pred-comp s ω c fx fx₂
%			  in complete-scanner a (pred-comp ω) x₁ i j g refl refl
%
%			complete*-step : ∀ {a₀ a t v} ->
%			  (Σ λ u -> u ++ (a₀ ∷ a ∷ v) ≡ t) ∣ (a ∷ v) ≡ t ->
%			  (ω : WSet t (a ∷ v)) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a₀ ∷ a ∷ v ⟶* X / α ∙ r a₀ ∷ β) ->
%			    (i : Item t (a ∷ v)) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ a ∷ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item (a ∷ v) (a ∷ v)) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  Complete* (step ω)
%			complete*-step s ω c fx fx₂ =
%			  complete-pred-comp s ω c fx fx₂
%
%			complete-parse₀ : ∀ {a t v} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  Complete (parse₀ ω)
%			complete-parse₀ {a₀} {t} {v = ε} k ω c fx fx₂ = complete-pred-comp k ω c fx fx₂
%			complete-parse₀ {a₀} {t} {v = a ∷ v} k ω c fx fx₂ =
%			  let
%			    x₁ = complete-pred-comp k ω c fx fx₂
%			    x₂ = case k of
%			      λ { (r refl) → l (σ ε refl)
%			        ; (l (σ p₁ p₀)) → l (σ (p₁ ←∷ a₀) (trans (sym (in₀ _ _ _)) (sym p₀)))
%			        }
%			  in
%			  complete-parse₀ {v = v} x₂ (step ω) x₁
%			    (λ {g i refl → complete-scanner a (pred-comp ω) x₁
%			      (_ ∘ _ ↦ _ ∘ _ [ v-unstep (Item.χ i) ∘ Item.ψ i ]) i g refl refl})
%			    (λ {refl x₂ i x₃ → case k of
%			      λ { (r ())
%			        ; (l (σ p₁ p₀)) → void (ε.ε₂ decidₜ (trans (sym (in₀ _ _ _)) (sym p₀)))
%			        }
%			      })
%
%			complete₀-itemize : ∀ w {β} ->
%			  (rs : (Σ λ t -> (t ∈ CFG.rules G) × (fst t ≡ CFG.start G)) *) ->
%			  (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			  (CFG.start G , β) ∈ map Σ.proj₁ rs ->
%			  (i : Item w w) ->
%			  i ≋ initial x ->
%			    i ∈ itemize w rs
%			complete₀-itemize w ε x () i refl
%			complete₀-itemize w (σ (X , β) p₀ ∷ rs) x in-head i refl = in-head
%			complete₀-itemize w (σ (X , β) p₀ ∷ rs) x (in-tail p) i refl =
%			  in-tail (complete₀-itemize w rs x p i refl)
%
%			complete-itemize : ∀ w {β} ->
%			  (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			  (i : Item w w) ->
%			  i ≋ initial x ->
%			    i ∈ itemize w (lookup (CFG.start G) (CFG.rules G))
%			complete-itemize w x i refl =
%			  let x₁ = Σ.proj₀ (lookup-sound x) in
%			  complete₀-itemize w (lookup _ _) x (in-map Σ.proj₁ x₁) i refl
%
%			complete-parse : ∀ a₀ w ->
%			  Complete (parse w)
%			complete-parse a₀ ε =
%			  complete-parse₀ {a = a₀} (r refl) (start (itemize ε (lookup _ _))) top
%			    (λ {g i x → void (test₃ (suff-g₂ g))})
%			    (λ {refl x i x₁ → complete-itemize ε x i x₁})
%			complete-parse a₀ (x ∷ w) =
%			  let
%			    x₁ = start (itemize (x ∷ w) (lookup _ _))
%			    x₂ = complete-pred-comp {a = a₀} (r refl) x₁ top
%			      (λ {g i x₂ → void (test₃ (suff-g₂ g))})
%			      (λ {refl x₂ i refl → complete-itemize (x ∷ w) x₂ i refl})
%			  in
%			  complete-parse₀ (l (σ ε refl)) (step x₁) x₂
%			    (λ g i x₃ → complete-step {a₀ = x} (r refl) x₁ top
%			      (λ {g₁ i₁ x₄ → void (test₃ (suff-g₂ g₁))})
%			      (λ {refl x₄ i₁ x₅ → complete-itemize (x ∷ w) x₄ i₁ x₅})
%			      (_ ∘ _ ↦ _ ∘ _ [ in-g g ∘ suff-g₁ g ]) i g refl x₃)
%			    (λ ())
%
%		\end{code}

	\section{Parse trees}

