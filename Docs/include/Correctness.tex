
\chapter{Correctness proofs}
	
	\section{Soundness}
		\begin{code}

			-- Valid items, those that are Earley-derivable.
			
			Valid : ∀ {w v} -> Item w v -> Set
			Valid {w} {v} i = G ⊢ Item.u i / v ⟶* Item.Y i / Item.β i
			
			-- Sound state sets (contain only valid items).
			
			Sound : ∀ {w v} -> WSet w v -> Set
			Sound (start rs) = ∀ {i} -> i ∈ rs -> Valid i
			Sound (step ω rs) = Sound ω × (∀ {i} -> i ∈ rs -> Valid i)
			
			H : ∀ {v w} {ω : WSet w v} -> Sound ω -> (∀ {i} -> i ∈ Sₙ ω -> Valid i)
			H {ω = start rs} s = s
			H {ω = step ω rs} s = snd s
			
			sound-scanner-w₀ : ∀ {a v w} -> ∀ rs ->
			  (∀ {i} -> i ∈ rs -> Valid i) ->
			  (∀ {i} -> i ∈ scanner-w₀ {w} {v} a rs -> Valid i)
			sound-scanner-w₀ ε f ()
			sound-scanner-w₀ ((X ∘ u ↦ α ∘ ε) ∷ rs) f p = sound-scanner-w₀ rs (f ∘ in-tail) p
			sound-scanner-w₀ ((X ∘ u ↦ α ∘ l Y ∷ β) ∷ rs) f p = sound-scanner-w₀ rs (f ∘ in-tail) p
			sound-scanner-w₀ {a} ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) f p with decidₜ a b
			sound-scanner-w₀ {a} ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) f p | no x = sound-scanner-w₀ rs (f ∘ in-tail) p
			sound-scanner-w₀ {a} ((X ∘ u ↦ α ∘ r a ∷ β) ∷ rs) f in-head | yes refl = scanner (f in-head)
			sound-scanner-w₀ {a} ((X ∘ u ↦ α ∘ r a ∷ β) ∷ rs) f (in-tail p) | yes refl
			  = sound-scanner-w₀ rs (f ∘ in-tail) p
			
			sound-scanner-w : ∀ {a w v} -> (ω : WSet w (a ∷ v)) ->
			  Sound ω -> Sound (scanner-w a ω)
			sound-scanner-w (start rs) s = s , sound-scanner-w₀ rs s
			sound-scanner-w (step w rs) (s , s₁) = s , s₁ , sound-scanner-w₀ rs s₁
			
			sound-complete-w₀ : ∀ {u v w} (w : WSet w v) ->
			  Sound w -> (∀ {i} -> i ∈ complete-w₀ {u} {v} w -> Valid i)
			sound-complete-w₀ {u} {v} w s p           with eq-T* u v
			sound-complete-w₀ {v} {v} w s p           | yes refl = H s p
			sound-complete-w₀ {u} {v} (start rs) s () | no x
			sound-complete-w₀ {u} {v} (step w rs) s p | no x = sound-complete-w₀ w (fst s) p
			
			sound-complete-w₁ : ∀ {u v w} ->
			  (i : Item w v) ->
			  (p : Item.β i ≡ ε) ->
			  (q : Item.u i ≡ u) ->
			  (rs : Item w u *) ->
			  Valid i -> (∀ {j} -> j ∈ rs -> Valid j) ->
			  (∀ {j} -> j ∈ complete-w₁ i p rs -> Valid j)
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ε v f ()
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ((Y ∘ u₁ ↦ α₁ ∘ ε) ∷ rs) v f q = sound-complete-w₁ _ refl refl rs v (f ∘ in-tail) q
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ((Y ∘ u₁ ↦ α₁ ∘ r a ∷ β) ∷ rs) v f q = sound-complete-w₁ _ refl refl rs v (f ∘ in-tail) q
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ((Y ∘ u₁ ↦ α₁ ∘ l Z ∷ β) ∷ rs) v f q           with decidₙ X Z
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ((Y ∘ u₁ ↦ α₁ ∘ l Z ∷ β) ∷ rs) v f q           | no x = sound-complete-w₁ _ refl refl rs v (f ∘ in-tail) q
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ((Y ∘ u₁ ↦ α₁ ∘ l X ∷ β) ∷ rs) v f in-head     | yes refl = complet (f in-head) v
			sound-complete-w₁ (X ∘ u ↦ α ∘ ε) refl refl ((Y ∘ u₁ ↦ α₁ ∘ l X ∷ β) ∷ rs) v f (in-tail q) | yes refl = sound-complete-w₁ _ refl refl rs v (f ∘ in-tail) q
			
			sound-complete-w₂ : ∀ {v w} ->
			  (i : Item w v) ->
			  (p : Item.β i ≡ ε) ->
			  Valid i -> (ω : WSet w v) -> Sound ω ->
			  (∀ {j} -> j ∈ complete-w₂ i p ω -> Valid j)
			sound-complete-w₂ i p v ω s q =
			  sound-complete-w₁ i p refl (complete-w₀ ω) v (sound-complete-w₀ ω s) q
			
			sound-predict-w₀ : ∀ {v w  Y β} ->
			  (ψ₁ : Σ λ t -> t ++ v ≡ w) ->
			  (i : Item w v) -> (p : Item.β i ≡ l Y ∷ β) ->
			  (f : (Σ λ t -> (t ∈ CFG.rules G) × (fst t ≡ Y)) *) ->
			  Valid i ->
			  (∀ {j} -> j ∈ predict-w₀ ψ₁ i p f -> Valid j)
			sound-predict-w₀ ψ₁ (X ∘ u ↦ α ∘ l Y ∷ β) refl ε v ()
			sound-predict-w₀ ψ₁ (X ∘ u ↦ α ∘ l Y ∷ β) refl (σ (Y , γ) (p , refl) ∷ f) v in-head = predict p v
			sound-predict-w₀ ψ₁ (X ∘ u ↦ α ∘ l Y ∷ β) refl (σ (Y , γ) (p , refl) ∷ f) v (in-tail q) =
			  sound-predict-w₀ ψ₁ _ refl f v q
			
			sound-predict-w₁ : ∀ {v w Y β} ->
			  (i : Item w v) ->  (p : Item.β i ≡ l Y ∷ β) ->
			  (w : WSet w v) ->
			  Valid i -> Sound w ->
			  (∀ {j} -> j ∈ predict-w₁ i p w -> Valid j)
			sound-predict-w₁ (X ∘ u ↦ α ∘ l Y ∷ β) refl ω v s q =
			  sound-predict-w₀ (V ω) _ refl (lookup Y (CFG.rules G)) v q
			
			sound-pred-comp-w₀ : ∀ {u v w X α β} -> ∀ .χ .ψ
			  (i : Item w v) -> (p : i ≡ (X ∘ u ↦ α ∘ β [ χ ∘ ψ ])) ->
			  (w : WSet w v) ->
			  Valid i -> Sound w ->
			  (∀ {j} -> j ∈ Σ.proj₁ (pred-comp-w₀ i w) -> Valid j)
			sound-pred-comp-w₀ χ ψ i@(X ∘ u ↦ α ∘ ε) refl w v s q =
			  sound-deduplicate (complete-w₂ i refl w) (sound-complete-w₂ i refl v w s) q
			sound-pred-comp-w₀ χ ψ i@(X ∘ u ↦ α ∘ r a ∷ β) refl w v s ()
			sound-pred-comp-w₀ χ ψ i@(X ∘ u ↦ α ∘ l Y ∷ β) refl w v s q =
			  sound-deduplicate (predict-w₁ i refl w) (sound-predict-w₁ i refl w v s) q
			
			sound-Wₙ : ∀ {w v ss} (ω : WSet w v) ->
			  (∀ {i} -> i ∈ ss -> Valid i) ->
			  Sound ω -> Sound (Wₙ ω ss)
			sound-Wₙ (start rs) f s = f
			sound-Wₙ (step ω rs) f s = fst s , f
			
			sound-pred-comp-w₁ : ∀ {w v} (ω : WSet w v) -> ∀ ss rs ->
			  (∀ {i} -> i ∈ ss -> Valid i) ->
			  (∀ {i} -> i ∈ rs -> Valid i) ->
			  Sound ω -> (∀ {i} -> i ∈ pred-comp-w₁ ω ss rs -> Valid i)
			sound-pred-comp-w₁ ω ss ε f g s ()
			sound-pred-comp-w₁ ω ss (x ∷ rs) f g s p =
			  let x₁ = sound-pred-comp-w₀ _ _ x refl (Wₙ ω ss) (g in-head) (sound-Wₙ ω f s) in
			  let x₂ = sound-pred-comp-w₁ ω ss rs f (g ∘ in-tail) s in
			  in-either Valid x₁ x₂ p
			
			sound-pred-comp-w₂ : ∀ {w v} (ω : WSet w v) -> ∀ ss rs m p q ->
			  (∀ {i} -> i ∈ ss -> Valid i) ->
			  (∀ {i} -> i ∈ rs -> Valid i) ->
			  Sound ω -> Sound (pred-comp-w₂ ω ss rs m p q)
			sound-pred-comp-w₂ ω ss rs zero () q f g s
			sound-pred-comp-w₂ ω ss ε (suc m) p q f g s = sound-Wₙ ω f s
			sound-pred-comp-w₂ ω ss rs@(r₁ ∷ _) (suc m) p q f g s =
			  let x₁ = pred-comp-w₁ ω ss rs in
			  let x₂ = x₁ \\ (rs ++ ss) in
			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q  in
			  let p₂ = wf-pcw₂ x₁ (rs ++ ss) q in
			  let p₃ = sound-pred-comp-w₁ ω ss rs f g s in
			  let p₄ = s-pcw₀ Valid p₃ in
			  sound-pred-comp-w₂ ω (rs ++ ss) x₂ m p₁ p₂ (in-either Valid g f) p₄ s
			
			sound-pred-comp-w : ∀ {w v} {ω : WSet w v} ->
			  Sound ω -> Sound (pred-comp-w ω)
			sound-pred-comp-w {w} {v} {ω} s =
			  let x₁ = deduplicate (Sₙ ω) in
			  let x₂ = (unique-++ (Σ.proj₁ x₁) ε (Σ.proj₀ x₁) u-ε λ ()) in
			  let m = suc (length (Σ.proj₁ (all-rules {w}) \\ ε)) in
			  sound-pred-comp-w₂ ω ε (Σ.proj₁ x₁) m (≤ₛ (≤-self _)) x₂ (λ ())
			    (sound-deduplicate (Sₙ ω) (H s))
			    s
			
			sound-step-w : ∀ {w a v} {ω : WSet w (a ∷ v)} ->
			  Sound ω -> Sound (step-w ω)
			sound-step-w {ω = ω} s = sound-scanner-w (pred-comp-w ω) (sound-pred-comp-w s)
			
			sound-parse : ∀ {w v} -> {ω : WSet w v} ->
			  Sound ω -> Sound (parse ω)
			sound-parse {v = ε} s = sound-pred-comp-w s
			sound-parse {v = x ∷ v} s = sound-parse (sound-step-w s)

		\end{code}
		  
%	\section{Completeness}
%		
%		\begin{code}
%
%			_≋_ : ∀ {t u v X α β} -> (i : Item t v) -> G ∙ t ⊢ u / v ⟶* X / α ∙ β -> Set
%			_≋_ {t} {u} {v} {X} {α} {β} i g = (Item.Y i , Item.u i , Item.α i , Item.β i) ≡ (X , u , α , β)
%			
%			eq-prop : {a b : T *} (P : Item a b -> Set) (i : Item b b) -> a ≡ b -> Set
%			eq-prop P i refl = P i
%			
%			Complete₀ : ∀ {t v} -> WSet t v -> Set
%			Complete₀ {t} {v} ω = ∀ {u Y α β} ->
%			  (i : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* Y / α ∙ β) ->
%			  i ≋ g ->
%			  i ∈ Sₙ ω
%			
%			mutual
%			  Complete : ∀ {v w} -> WSet w v -> Set
%			  Complete ω = Complete₀ ω × Complete* ω
%			
%			  Complete* : ∀ {v w} -> WSet w v -> Set
%			  Complete* (start rs) = ⊤
%			  Complete* (step ω rs) = Complete ω
%			
%			complete-scanner-w₀ : ∀ {t u v X α β} -> ∀ a rs ->
%			  (i : Item t (a ∷ v)) ->
%			  (j : Item t v) ->
%			  (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			  i ≋ g -> i ∈ rs ->
%			  j ≋ scanner g ->
%			    j ∈ scanner-w₀ a rs
%			complete-scanner-w₀ a ε i j g refl () refl
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ ε) ∷ rs)       i j g refl (in-tail p) refl = complete-scanner-w₀ a rs i j g refl p refl
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ l Y ∷ β) ∷ rs) i j g refl (in-tail p) refl = complete-scanner-w₀ a rs i j g refl p refl
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) i j g refl p           refl with decidₜ a b
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) i j g refl in-head     refl | yes refl = in-head
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) i j g refl (in-tail p) refl | yes refl = in-tail (complete-scanner-w₀ a rs i j g refl p refl)
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) i j g refl in-head     refl | no x = void (x refl)
%			complete-scanner-w₀ a ((X ∘ u ↦ α ∘ r b ∷ β) ∷ rs) i j g refl (in-tail p) refl | no x = complete-scanner-w₀ a rs i j g refl p refl
%			
%			complete-scanner-w : ∀ {t u v X α β} -> ∀ a ->
%			  (ω : WSet t (a ∷ v)) ->
%			  Complete ω ->
%			  (i : Item t (a ∷ v)) ->
%			  (j : Item t v) ->
%			  (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			  i ≋ g ->
%			  j ≋ scanner g ->
%			    j ∈ Sₙ (scanner-w a ω)
%			complete-scanner-w a ω@(start rs) c  i j g refl refl with (fst c) i g refl
%			complete-scanner-w a ω@(start rs) c  i j g refl refl | d = complete-scanner-w₀ a (Sₙ ω) i j g refl d refl
%			complete-scanner-w a ω@(step _ rs) c i j g refl refl with (fst c) i g refl
%			complete-scanner-w a ω@(step _ rs) c i j g refl refl | d = complete-scanner-w₀ a (Sₙ ω) i j g refl d refl
%			
%			test : ∀ {a t v} ->
%			  {P : Item t v -> Set} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    P i
%			  ) ->
%			
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop P i z
%			  ) ->
%			
%			  (∀ {u X Y α β δ} (x : (Y , δ) ∈ CFG.rules G) ->
%			    (i j : Item t v) ->
%			    (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			    (i ≋ g) -> P i ->
%			    (j ≋ predict x g) -> P j
%			  ) ->
%			
%			  (∀ {u w X Y α β γ} ->
%			    (j k : Item t v) ->
%			    (g : G ∙ t ⊢ u / w ⟶* X / α ∙ l Y ∷ β) ->
%			    (h : G ∙ t ⊢ w / v ⟶* Y / γ ∙ ε) ->
%			    (j ≋ h) -> P j ->
%			    (k ≋ complet g h) -> P k
%			  ) ->
%			
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			    (i : Item t v) ->
%			    i ≋ g ->
%			    P i
%			  )
%			test s f ini h c (initial x) i refl = ini refl x i refl
%			test {a} s f ini h c (scanner g) i p = case test₀ s g of λ {refl -> f g i p}
%			test s f ini h c (predict x g) i@(X ∘ u ↦ α ∘ β [ χ ∘ ψ ]) refl =
%			  h x (_ ∘ _ ↦ _ ∘ _ [ in-g g ∘ suff-g₁ g ]) i g refl (test s f ini h c g _ refl) refl
%			test s f ini h c (complet g g₁) i p =
%			  c (_ ∘ _ ↦ _ ∘ _ [ in-g g₁ ∘ suff-g₂ g ]) i g g₁ refl (test s f ini h c g₁ _ refl) p
%			
%			complete-predict-w₀ : ∀ {t u v X Y α β δ} ->
%			  (ψ₀ : Σ λ s -> s ++ v ≡ t) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ v / v ⟶* Y / ε ∙ δ) ->
%			  (p : i ≋ g) ->
%			  (q : j ≋ h) ->
%			  (rs : (Σ λ t -> (t ∈ CFG.rules G) × (fst t ≡ Y)) *) ->
%			  (Σ λ e -> σ (Y , δ) e ∈ rs) ->
%			  j ∈ predict-w₀ ψ₀ i (≋-β i g p) rs
%			complete-predict-w₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl ε (σ p₁ ())
%			complete-predict-w₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , γ) (p , refl) ∷ rs) q with eq-α γ δ
%			complete-predict-w₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , δ) (p , refl) ∷ rs) q | yes refl = in-head
%			complete-predict-w₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , δ) (p , refl) ∷ rs) (σ (q , refl) in-head) | no x = void (x refl)
%			complete-predict-w₀ ψ₀ (X ∘ u ↦ α ∘ l Y ∷ β) (Y ∘ u₁ ↦ ε ∘ δ) g h refl refl (σ (Y , γ) (p , refl) ∷ rs) (σ q₁ (in-tail q₀)) | no x =
%			  in-tail (complete-predict-w₀ ψ₀ _ _ g h refl refl rs (σ q₁ q₀))
%			
%			complete-predict-w₁ : ∀ {t u v X Y α β δ} ->
%			  (ω : WSet t v) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  (x : CFG.rules G ∋ (Y , δ)) ->
%			  (p : i ≋ g) ->
%			  j ≋ predict x g ->
%			  j ∈ predict-w₁ i (≋-β i g p) ω
%			complete-predict-w₁ ω i@(X ∘ u ↦ α ∘ l Y ∷ β) j g x refl q =
%			  complete-predict-w₀ _ i j g (predict x g) refl q (lookup Y (CFG.rules G)) (lookup-sound x)
%			
%			complete-deduplicate : ∀ {w v i} -> (as : Item w v *) -> i ∈ as -> i ∈ Σ.proj₁ (deduplicate as)
%			complete-deduplicate ε ()
%			complete-deduplicate (x ∷ as) p with elem eq-item x (Σ.proj₁ (deduplicate as))
%			complete-deduplicate (x ∷ as) in-head     | yes x₁ = x₁
%			complete-deduplicate (x ∷ as) (in-tail p) | yes x₁ = complete-deduplicate as p
%			complete-deduplicate (x ∷ as) in-head     | no x₁ = in-head
%			complete-deduplicate (x ∷ as) (in-tail p) | no x₁ = in-tail (complete-deduplicate as p)
%			
%			complete₁-pred-comp-w₀ : ∀ {t u v X Y α β δ} ->
%			  (ω : WSet t v) ->
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> 
%			  j ≋ predict x g ->
%			    j ∈ Σ.proj₁ (pred-comp-w₀ i ω)
%			complete₁-pred-comp-w₀ ω x i@(Y ∘ u ↦ α ∘ l Z ∷ β) j@(Z ∘ u₁ ↦ ε ∘ β₁ [ χ₁ ∘ ψ₁ ]) g refl refl =
%			  let x₁ = complete-predict-w₁ ω i j g x refl refl in
%			  complete-deduplicate (predict-w₁ i refl ω) x₁
%			
%			complete₂-pred-comp-w₀ : ∀ {t u v w X Y α β γ} ->
%			  (ω : WSet t w) ->
%			  (i j : Item t w) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ v / w ⟶* Y / γ ∙ ε) ->
%			  i ≋ h -> 
%			  j ≋ complet g h ->
%			    j ∈ Σ.proj₁ (pred-comp-w₀ i ω)
%			complete₂-pred-comp-w₀ ω i j g h refl refl =
%			  complete-deduplicate (complete-w₂ i refl ω) {!!}
%			
%			complete₁-pred-comp-w₁ : ∀ {t u v X Y α β δ ss} -> ∀ rs ->
%			  (ω : WSet t v)
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> 
%			  i ∈ rs ->
%			  j ≋ predict x g ->
%			    j ∈ pred-comp-w₁ ω ss rs
%			complete₁-pred-comp-w₁ {ss = ss} (i  ∷ rs) ω x i j g o in-head q =
%			  in-l (complete₁-pred-comp-w₀ (Wₙ ω ss) x i j g o q)
%			complete₁-pred-comp-w₁ (r₁ ∷ rs) ω x i j g o (in-tail p) q =
%			  in-r (complete₁-pred-comp-w₁ rs ω x i j g o p q)
%			
%			complete₁₀-pred-comp-w₂ : ∀ {t v ss rs m p q} ->
%			  (ω : WSet t v) ->
%			  (i : Item t v) ->
%			  i ∈ ss ->
%			  i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			complete₁₀-pred-comp-w₂ {ss = ss} {rs} {zero} {()} ω i s
%			complete₁₀-pred-comp-w₂ {ss = ss} {ε} {suc m} {p} (start rs) i s = s
%			complete₁₀-pred-comp-w₂ {ss = ss} {ε} {suc m} {p} (step ω rs) i s = s
%			complete₁₀-pred-comp-w₂ {ss = ss} {rs@(_ ∷ _)} {suc m} {p} {q} ω i s =
%			  complete₁₀-pred-comp-w₂ {m = m} ω i (in-r s)
%			
%			complete₁₁-pred-comp-w₂ : ∀ {t v ss rs m p q} ->
%			  (ω : WSet t v) ->
%			  (i : Item t v) ->
%			  i ∈ rs ->
%			  i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			complete₁₁-pred-comp-w₂ {ss = ss} {rs} {zero} {()} ω i s
%			complete₁₁-pred-comp-w₂ {ss = ss} {ε} {suc m} {p} ω i ()
%			complete₁₁-pred-comp-w₂ {ss = ss} {rs@(_ ∷ _)} {suc m} {p} ω i s =
%			  complete₁₀-pred-comp-w₂ {m = m} ω i (in-l s)
%			
%			complete₁₂-pred-comp-w₂ : ∀ {t v ss rs m p q} ->
%			  (ω : WSet t v) ->
%			  ∀ {u X Y α β δ} ->
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> i ∈ rs ->
%			  j ≋ predict x g -> j ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			complete₁₂-pred-comp-w₂ {ss = ss} {rs} {zero} {p = ()} ω x i j g p p' q
%			complete₁₂-pred-comp-w₂ {ss = ss} {ε} {suc m} ω x i j g p () q
%			complete₁₂-pred-comp-w₂ {ss = ss} {rs@(_ ∷ _)} {suc m} ω x i j g p p' q =
%			  let x₁ = pred-comp-w₁ ω ss rs in
%			  let x₂ = x₁ \\ (rs ++ ss) in
%			  let y₁ = complete₁-pred-comp-w₁ rs ω x i j g p p' q in
%			  let y₂ = include-\\ {as = x₁} {bs = rs ++ ss} y₁ in
%			  case in-lr x₂ (rs ++ ss) y₂ of
%			    λ { (r z) → complete₁₀-pred-comp-w₂ {m = m} ω j z
%			      ; (l z) → complete₁₁-pred-comp-w₂ {m = m} ω j z
%			      }
%			
%			Nx : ∀ {t v} -> Item t v * -> Item t v * -> Set
%			Nx {t} {v} ss rs =
%			  ∀ {u X Y α β δ} ->
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> i ∈ ss ->
%			  j ≋ predict x g ->
%			    j ∈ (rs ++ ss)
%			
%			nx' : ∀ {t v rs ss} (ω : WSet t v) ->
%			  Nx ss rs ->
%			  Nx (rs ++ ss) (pred-comp-w₁ ω ss rs \\ (rs ++ ss))
%			nx' {rs = ε} {ss} ω nx x i j g z₁ z₂ z₃ = nx x i j g z₁ z₂ z₃
%			nx' {rs = rs@(r₁ ∷ rs₀)} {ss} ω nx x i j g z₁ z₂ z₃ =
%			  case in-lr rs ss z₂ of
%			    λ { (r x₁) →
%			      let x₁ = nx x i j g z₁ x₁ z₃  in
%			      in-r x₁
%			    ; (l x₁) →
%			      let y₁ = complete₁-pred-comp-w₁ rs ω x i j g z₁ x₁ z₃ in
%			      include-\\ y₁
%			    }
%			
%			complete₁-pred-comp-w₂ : ∀ {t v} -> ∀ ss rs m p q ->
%			  (ω : WSet t v) ->
%			  Nx ss rs ->
%			  ∀ {u X Y α β δ}
%			  (x : (Y , δ) ∈ CFG.rules G) ->
%			  (i j : Item t v) ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β) ->
%			  i ≋ g -> 
%			  i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q) ->
%			  j ≋ predict x g ->
%			    j ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			complete₁-pred-comp-w₂ ss rs            zero    () q ω           nx x i j g z₁ z₂ z₃
%			complete₁-pred-comp-w₂ ss ε             (suc m) p  q (start rs)  nx x i j g z₁ z₂ z₃ =
%			  nx x i j g z₁ z₂ z₃ 
%			complete₁-pred-comp-w₂ ss ε             (suc m) p  q (step ω rs) nx x i j g z₁ z₂ z₃ =
%			  nx x i j g z₁ z₂ z₃
%			complete₁-pred-comp-w₂ ss rs@(r₁ ∷ rs₀) (suc m) p  q ω           nx x i j g z₁ z₂ z₃ =
%			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q in
%			  let q₁ = wf-pcw₂ (pred-comp-w₁ ω ss rs) (rs ++ ss) q in
%			  complete₁-pred-comp-w₂ (rs ++ ss) _ m p₁ q₁ ω (nx' ω nx) x i j g z₁ z₂ z₃
%			
%			Nx₂ : ∀ {t v} -> Item t v * -> Item t v * -> Set
%			Nx₂ {t} {v} ss rs =
%			  ∀ {u w X Y α β γ} ->
%			  (j k : Item t v) ->
%			  (g : G ∙ t ⊢ u / w ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ w / v ⟶* Y / γ ∙ ε) ->
%			  j ≋ h -> j ∈ ss ->
%			  k ≋ complet g h ->
%			    k ∈ (rs ++ ss)
%			
%			nx₂' : ∀ {t v rs ss} (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx₂ ss rs ->
%			  Nx₂ (rs ++ ss) (pred-comp-w₁ ω ss rs \\ (rs ++ ss))
%			nx₂' {rs = ε} {ss} ω c nx x i j g z₁ z₂ z₃ = nx x i j g z₁ z₂ z₃
%			nx₂' {rs = rs@(r₁ ∷ rs₀)} {ss} ω c nx x i j g z₁ z₂ z₃ =
%			  case in-lr rs ss z₂ of
%			    λ { (r x₁) →
%			      let x₁ = nx x i j g z₁ x₁ z₃  in
%			      in-r x₁
%			    ; (l x₁) → {!!}
%			    }
%			
%			complete₂-pred-comp-w₂ : ∀ {t v} -> ∀ ss rs m p q ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx₂ ss rs ->
%			  ∀ {u w X Y α β γ}
%			  (j k : Item t v) ->
%			  (g : G ∙ t ⊢ u / w ⟶* X / α ∙ l Y ∷ β) ->
%			  (h : G ∙ t ⊢ w / v ⟶* Y / γ ∙ ε) ->
%			  j ≋ h -> j ∈ Sₙ (pred-comp-w₂ ω ss rs m p q) ->
%			  k ≋ complet g h ->
%			    k ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			complete₂-pred-comp-w₂ ss rs            zero    () q ω           c nx x i j g z₁ z₂ z₃
%			complete₂-pred-comp-w₂ ss ε             (suc m) p  q (start rs)  c nx x i j g z₁ z₂ z₃ =
%			  nx x i j g z₁ z₂ z₃ 
%			complete₂-pred-comp-w₂ ss ε             (suc m) p  q (step ω rs) c nx x i j g z₁ z₂ z₃ =
%			  nx x i j g z₁ z₂ z₃
%			complete₂-pred-comp-w₂ ss rs@(r₁ ∷ rs₀) (suc m) p  q ω           c nx x i j g z₁ z₂ z₃ =
%			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q in
%			  let q₁ = wf-pcw₂ (pred-comp-w₁ ω ss rs) (rs ++ ss) q in
%			  complete₂-pred-comp-w₂ (rs ++ ss) _ m p₁ q₁ ω c (nx₂' ω c nx) x i j g z₁ z₂ z₃
%			
%			complete-pred-comp-w₂ : ∀ {a t v ss rs m p q} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx ss rs ->
%			  Nx₂ ss rs ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (λ i -> i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)) i z
%			  ) ->
%			  ∀ {u X α β} ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			  (i : Item t v) ->
%			  i ≋ g -> i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)
%			complete-pred-comp-w₂ {a} {t} {v} {ss} {rs} {m} {p} {q} h ω c nx nx₂ s u g i e =
%			  test {P = λ i -> i ∈ Sₙ (pred-comp-w₂ ω ss rs m p q)}
%			    h
%			    s
%			    u 
%			    (complete₁-pred-comp-w₂ ss rs m p q ω nx)
%			    (complete₂-pred-comp-w₂ ss rs m p q ω c nx₂)
%			    g i e
%			
%			complete₀-pred-comp-w : ∀ {a t v} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Nx ε (Σ.proj₁ (deduplicate (Sₙ ω))) ->
%			  Nx₂ ε (Σ.proj₁ (deduplicate (Sₙ ω))) ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ (Σ.proj₁ (deduplicate (Sₙ ω)))
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (_∈ Σ.proj₁ (deduplicate (Sₙ ω))) i z
%			  ) ->
%			  ∀ {u X α β} ->
%			  (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			  (i : Item t v) ->
%			  i ≋ g -> i ∈ Sₙ (pred-comp-w ω)
%			complete₀-pred-comp-w {a} {t} s ω c nx nx₂ fx fx₂ g i p =
%			  let x₁ = deduplicate (Sₙ ω) in
%			  let x₂ = (unique-++ (Σ.proj₁ x₁) ε (Σ.proj₀ x₁) u-ε λ ()) in
%			  complete-pred-comp-w₂ {p = ≤ₛ (≤-self _)} {q = x₂} s ω c nx nx₂
%			    (λ g₁ i₁ x → complete₁₁-pred-comp-w₂ {p = ≤ₛ (≤-self _)} {q = x₂} ω i₁ (fx g₁ i₁ x))
%			    (λ {refl x i₁ x₃ → complete₁₁-pred-comp-w₂ {p = ≤ₛ (≤-self _)} {q = x₂} ω i₁ (fx₂ refl x i₁ x₃)})
%			    g i p
%			
%			complete₃-pred-comp-w₂ : ∀ {t v} -> ∀ ss rs m p q ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Complete* (pred-comp-w₂ ω ss rs m p q)
%			complete₃-pred-comp-w₂ ss rs zero () q ω c
%			complete₃-pred-comp-w₂ ss ε (suc m) p q (start rs) c = top
%			complete₃-pred-comp-w₂ ss ε (suc m) p q (step ω rs) c = c
%			complete₃-pred-comp-w₂ ss rs@(_ ∷ _) (suc m) p q ω c =
%			  let x₁ = pred-comp-w₁ ω ss rs in
%			  let x₂ = x₁ \\ (rs ++ ss) in
%			  let p₁ = wf-pcw₃ (Σ.proj₀ all-rules) p q in
%			  let q₁ = wf-pcw₂ x₁ (rs ++ ss) q in
%			  complete₃-pred-comp-w₂ (rs ++ ss) x₂ m p₁ q₁ ω c 
%			
%			complete₁-pred-comp-w : ∀ {t v} ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  Complete* (pred-comp-w ω)
%			complete₁-pred-comp-w ω =
%			  let x₁ = deduplicate (Sₙ ω) in
%			  let x₂ = (unique-++ (Σ.proj₁ x₁) ε (Σ.proj₀ x₁) u-ε λ ()) in
%			  complete₃-pred-comp-w₂ ε _ _ (≤ₛ (≤-self _)) x₂ ω
%			  
%			complete₂-pred-comp-w : ∀ {t v} ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / v ⟶* X / α ∙ β) ->
%			    (i : Item t v) ->
%			    i ≋ g -> i ∈ Sₙ (pred-comp-w ω)
%			  ) ->
%			  Complete (pred-comp-w ω)
%			complete₂-pred-comp-w ω c f = (λ i g x → f g i x) , complete₁-pred-comp-w ω c
%			
%			complete-pred-comp-w : ∀ {a t v} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  Complete (pred-comp-w ω)
%			complete-pred-comp-w {a} {t} s ω c fx fx₂ =
%			  let
%			    x₅ = complete₀-pred-comp-w s ω c (λ x i j g x₁ ()) (λ j k g h x ())
%			      (λ {g i x → complete-deduplicate (Sₙ ω) (fx g i x)})
%			      λ {refl x i x₁ → complete-deduplicate (Sₙ ω) (fx₂ refl x i x₁)}
%			  in
%			  complete₂-pred-comp-w ω c x₅
%			
%			complete-step-w : ∀ {a₀ a t v} ->
%			  (Σ λ u -> u ++ (a₀ ∷ a ∷ v) ≡ t) ∣ (a ∷ v) ≡ t ->
%			  (ω : WSet t (a ∷ v)) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a₀ ∷ a ∷ v ⟶* X / α ∙ r a₀ ∷ β) ->
%			    (i : Item t (a ∷ v)) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ a ∷ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item (a ∷ v) (a ∷ v)) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  ∀ {u X α β} ->
%			  (i : Item t (a ∷ v)) ->
%			  (j : Item t v) ->
%			  (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			  i ≋ g ->
%			  j ≋ scanner g ->
%			    j ∈ Sₙ (step-w ω)
%			complete-step-w {a₀} {a} s ω c fx fx₂ i j g refl refl =
%			  let
%			    x₁ = complete-pred-comp-w s ω c fx fx₂
%			  in complete-scanner-w a (pred-comp-w ω) x₁ i j g refl refl
%			
%			complete*-step-w : ∀ {a₀ a t v} ->
%			  (Σ λ u -> u ++ (a₀ ∷ a ∷ v) ≡ t) ∣ (a ∷ v) ≡ t ->
%			  (ω : WSet t (a ∷ v)) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a₀ ∷ a ∷ v ⟶* X / α ∙ r a₀ ∷ β) ->
%			    (i : Item t (a ∷ v)) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ a ∷ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item (a ∷ v) (a ∷ v)) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  Complete* (step-w ω)
%			complete*-step-w s ω c fx fx₂ =
%			  complete-pred-comp-w s ω c fx fx₂
%			
%			complete-parse₀ : ∀ {a t v} ->
%			  (Σ λ u -> u ++ (a ∷ v) ≡ t) ∣ v ≡ t ->
%			  (ω : WSet t v) ->
%			  Complete* ω ->
%			  (∀ {u X α β} ->
%			    (g : G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β) ->
%			    (i : Item t v) -> (i ≋ scanner g) ->
%			    i ∈ Sₙ ω
%			  ) ->
%			  (∀ {β} ->
%			    (z : t ≡ v) ->
%			    (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			    (i : Item v v) ->
%			    i ≋ initial x -> eq-prop (_∈ Sₙ ω) i z
%			  ) ->
%			  Complete (parse₀ ω)
%			complete-parse₀ {a₀} {t} {v = ε} k ω c fx fx₂ = complete-pred-comp-w k ω c fx fx₂
%			complete-parse₀ {a₀} {t} {v = a ∷ v} k ω c fx fx₂ =
%			  let
%			    x₁ = complete-pred-comp-w k ω c fx fx₂
%			    x₂ = case k of
%			      λ { (r refl) → l (σ ε refl)
%			        ; (l (σ p₁ p₀)) → l (σ (p₁ ←∷ a₀) (trans (sym (in₀ _ _ _)) (sym p₀)))
%			        }
%			  in
%			  complete-parse₀ {v = v} x₂ (step-w ω) x₁
%			    (λ {g i refl → complete-scanner-w a (pred-comp-w ω) x₁
%			      (_ ∘ _ ↦ _ ∘ _ [ v-unstep (Item.χ i) ∘ Item.ψ i ]) i g refl refl})
%			    (λ {refl x₂ i x₃ → case k of
%			      λ { (r ())
%			        ; (l (σ p₁ p₀)) → void (ε.ε₂ decidₜ (trans (sym (in₀ _ _ _)) (sym p₀)))
%			        }
%			      })
%			
%			complete₀-itemize : ∀ w {β} ->
%			  (rs : (Σ λ t -> (t ∈ CFG.rules G) × (fst t ≡ CFG.start G)) *) ->
%			  (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			  (CFG.start G , β) ∈ map Σ.proj₁ rs ->
%			  (i : Item w w) ->
%			  i ≋ initial x ->
%			    i ∈ itemize w rs
%			complete₀-itemize w ε x () i refl
%			complete₀-itemize w (σ (X , β) p₀ ∷ rs) x in-head i refl = in-head
%			complete₀-itemize w (σ (X , β) p₀ ∷ rs) x (in-tail p) i refl =
%			  in-tail (complete₀-itemize w rs x p i refl)
%			
%			complete-itemize : ∀ w {β} ->
%			  (x : (CFG.start G , β) ∈ CFG.rules G) ->
%			  (i : Item w w) ->
%			  i ≋ initial x ->
%			    i ∈ itemize w (lookup (CFG.start G) (CFG.rules G))
%			complete-itemize w x i refl =
%			  let x₁ = Σ.proj₀ (lookup-sound x) in
%			  complete₀-itemize w (lookup _ _) x (in-map Σ.proj₁ x₁) i refl
%			
%			complete-parse : ∀ a₀ w ->
%			  Complete (parse w)
%			complete-parse a₀ ε =
%			  complete-parse₀ {a = a₀} (r refl) (start (itemize ε (lookup _ _))) top
%			    (λ {g i x → void (test₃ (suff-g₂ g))})
%			    (λ {refl x i x₁ → complete-itemize ε x i x₁})
%			complete-parse a₀ (x ∷ w) =
%			  let
%			    x₁ = start (itemize (x ∷ w) (lookup _ _)) 
%			    x₂ = complete-pred-comp-w {a = a₀} (r refl) x₁ top
%			      (λ {g i x₂ → void (test₃ (suff-g₂ g))})
%			      (λ {refl x₂ i refl → complete-itemize (x ∷ w) x₂ i refl})
%			  in
%			  complete-parse₀ (l (σ ε refl)) (step-w x₁) x₂
%			    (λ g i x₃ → complete-step-w {a₀ = x} (r refl) x₁ top
%			      (λ {g₁ i₁ x₄ → void (test₃ (suff-g₂ g₁))})
%			      (λ {refl x₄ i₁ x₅ → complete-itemize (x ∷ w) x₄ i₁ x₅})
%			      (_ ∘ _ ↦ _ ∘ _ [ in-g g ∘ suff-g₁ g ]) i g refl x₃)
%			    (λ ())
%			
%		\end{code}
