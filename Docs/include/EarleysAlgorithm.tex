% CREATED BY DAVID FRISK, 2016
\chapter{Earley's Algorithm}

	The Earley parsing algorithm, named after its inventor Jay Earley, was
	invented by Jay Earley in 1881~\cite{Earley}. It is a top-down parsing
	algorithm, meaning that it starts with analysing the large-scale structure
	if its input and using that as guidance for what analysis is needed when
	diving deeper into more fine-scale structure and eventually single tokens.
	Eearley parsing is interesting in that it is able to perform well on
	several commonly used types of grammars, such as the LR(k) grammars, while
	also being able to parse all context-free grammars. This section will first
	give a high-level description of the algorithm, followed by a formalization
	of its mechanics, and finally give our implementation of the algorithm in
	Agda.

	\section{Description}
		
		The Earley algorithm works by keeping track of a set of items
		representing possible partial parses for each consumption state of the
		input sequence. It advances over the sets from left to right, with each 
		step to the right representing the consumption, or \emph{`scanning`} of 
		one token. For each set, all items in it are iterated over, and they 
		are each checed if it and any item in the current or any previous set 
		together imply that the parsing can continue even further, resulting in 
		a new item. All new items are added to the current set, and the process 
		is then repeated until no new unique items can be formed.

		The items are of the form $(X \mapsto \alpha \cdot \beta, i)$, where
		$X$ is the nonterminal this item represents a partial parse of,
		$\alpha$ is the sequence of terminals and non-terminals that have
		already been successfully parsed, $\beta$ is what remains to be parsed,
		and $i$ is the index of the set where the parsing attempt of $X$ was
		started. New items can be constructed from previous items in one of
		three ways:

		\begin{itemize}
			\item 
				If $\beta$ is of the form $Y\delta$, meaning that for this item
				to be completed, a $Y$ must now be parsed at this position, a 
				new item $(Y \mapsto \epsilon \cdot \gamma, j)$ is added to the 
				current set.
			
			\item
				If $\beta$ is of the form $\epsilon$, meaning that this item
				could accept the string of tokens satring at $i$ and ending at
				$j$, we must find out why the parsing of $X$ was attempted in
				the first place. Any item $(Y \mapsto \alpha \cdot X\delta, k)$
				in set $i$  could have predicted this item, and as such, we
				will add a new item $(Y \mapsto \alpha X \cdot \delta, k)$ for 
				each such item.
			
			\item
				If $\beta$ is of the form $a\delta$, and the next token in the 
				input sequence is $a$, a new item 
				$(X \mapsto \alpha a \cdot \delta, i)$ is added to the next 
				set.

		\end{itemize}
		
		The algorithm is initialized with all sets empty except for the first
		one, where a single item $(S_0 \mapsto \epsilon \cdot S, 0)$ is
		inserted.  $S$ is the starting symbol, that is, the non-terminal which
		we want to find out if the input sequence conforms to or not. $S_0$ is
		a special marker that is only used for the initial item. When parsing
		of the input sequence is complet, iff in the last set there is an item
		$(S_0 \mapsto S \cdot \epsilon, 0)$ then the parser accepts, otherwise
		the parser rejects the input.

		Recreating the parse tree can be done via backtracking from the item 
		sets. The nifty thing about this algorithm is that each item only can 
		exist once in each item set, if the grammar is ambiguous and items can 
		be derived is several different ways (or even an unbounded number of 
		ways), the different derivations will all share their common items, 
		which gives the Earley parsing algorithm the ability to correctly 
		analyse ambiguous grammars.

	\section{Formalization}
		
		We will begin by defining a proposition for how and what items can be 
		added to the different sets.

		\begin{table}[h]
			\centering
			\begin{tabular}{cccc}
				initial & scanner & predict & complet
			\end{tabular}
		\end{table}

		A similar proposition can be constructed in Agda:

		\begin{code}

			data _∙_⊢_/_⟶*_/_∙_ (G : CFG) :
			  (t u v : T *) -> N -> (N ∣ T) * -> (N ∣ T) * -> Set where
			
			  initial : {u : T *} {α : (N ∣ T) *} ->
			    CFG.rules G ∋ (CFG.start G , α) ->
			    G ∙ u ⊢ u / u ⟶* CFG.start G / ε ∙ α
			
			  scanner : {t u v : T *} {a : T} {X : N} {α β : (N ∣ T) *} ->
			    G ∙ t ⊢ u / a ∷ v ⟶* X / α ∙ r a ∷ β ->
			      G ∙ t ⊢ u / v ⟶* X / α ←∷ r a ∙ β
			
			  predict : {t u v : T *} {X Y : N} {α β δ : (N ∣ T) *} -> 
			    CFG.rules G ∋ (Y , δ) ->
			    G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β ->
			      G ∙ t ⊢ v / v ⟶* Y / ε ∙ δ
			
			  complet : {t u v w : T *} {X Y : N} {α β γ : (N ∣ T) *} ->
			    G ∙ t ⊢ u / v ⟶* X / α ∙ l Y ∷ β ->
			    G ∙ t ⊢ v / w ⟶* Y / γ ∙ ε ->
			      G ∙ t ⊢ u / w ⟶* X / α ←∷ l Y ∙ β

		\end{code}

		Here, a value with type $G \cdot t \vdash u / v \rightarrow^* X /
		\alpha \cdot \beta$ would correspond to an item $(X \mapsto \alpha
		\cdot \beta, u)$ (using $u$ as a ramainder string rather than a
		consumed-index) in set $v$ that was generated while parsing the
		sequence $t$ with grammar $G$. 
		
		There are some differences between the propositions we first wrote for
		Earley parsers and the data type given above. The addition of an
		explicit grammar and sequence-to-be-parsed change little about the how
		the constructors can be used, but make it easier to reason about
		different grammars and ensure that the initial item will indeed only be
		put in the initial item set. The initial item has also been changed
		somewhat. Instead of introducing a special marker for the initial item,
		all rules for the starting symbol are now allowed as initial items.
		This also has little effect on the propositions, but introduces a
		useful (and probably expected) invariant: $\alpha \concat \beta \in 
		\textrm{CFG.rules } G$.
	
		\begin{code}
	
			sound : ∀ {u v w X β} {G : CFG} ->
			  G ⊢ u / v ⟶* X / β ->
			  G ⊢ v / w ∈ β ->
			    G ⊢ u / w ∈ l X ∷ ε
			sound initial b = b
			sound (scanner a) b = sound a (term b)
			sound (predict x a) b = nont x b
			sound (complet a a₁) b =
			  let x₁ = sound a₁ empt in
			  let x₂ = conc x₁ b in
			  sound a x₂
	
		\end{code}
	
		\begin{code}
			
			complete : ∀ {u v w X α} {G : CFG} ->
			  G ⊢ u / v ⟶* X / α ->
			  G ⊢ v / w ∈ α ->
			    G ⊢ u / w ⟶* X / ε
			complete a empt = a
			complete a (conc (conc b empt) b₁) = complete a (conc b b₁)
			complete a (conc (nont x b) b₁) =
			  let x₁ = predict x a in
			  let x₂ = complete x₁ b in
			  let x₃ = complet a x₂ in
			  complete x₃ b₁
			complete a (term b) = complete (scanner a) b
			complete a (nont x b) = complet a (complete (predict x a) b)
	
		\end{code}
	
	\section{Implementation}

		\begin{code}
	
			record Item (n : ℕ) : Set where
			  constructor _∘_↦_∘_
			  field
			    Y : N
			    j : ℕ
			    α β : (N ∣ T) *
			    .{χ} : CFG.rules G ∋ (Y , α ++ β)
			    .{ω} : j ≤ n
	
		\end{code}
	
		\begin{code}
	
			data WSet : ℕ -> T * -> Set where
			  start :
			    (v : T *) ->
			    (rs : Item zero * ) ->
			    WSet zero v
			
			  step : {a : T} {v : T *} {n : ℕ} ->
			    (w : WSet n (a ∷ v)) ->
			    (rs : Item (suc n) * ) ->
			    WSet (suc n) v
	
		\end{code}
		
		\begin{code}
	
			in-all : ∀ {j} -> (i : Item j) -> all-rules j ∋ i
	
		\end{code}
	
		\begin{code}
	
			step-w : ∀ {n a v} ->
			  WSet n (a ∷ v) ->
			  WSet (suc n) v
			step-w {a = a} {v = v} w = scanner-w a v (pred-comp-w w)
		
		\end{code}
