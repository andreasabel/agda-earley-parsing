% CREATED BY DAVID FRISK, 2016
\chapter{Earley's Algorithm}

	First, we will describe 

	\begin{code}
		data _⊢_/_⟶*_/_ (G : CFG) : T * -> T * -> N -> (N ∣ T) * -> Set where
		  initial : {u : T *} ->
		    G ⊢ u / u ⟶* CFG.start G / l (CFG.start G) ∷ ε
		
		  scanner : {u v : T *} {a : T} {X : N} {β : (N ∣ T) *} ->
		    G ⊢ u / a ∷ v ⟶* X / r a ∷ β ->
		      G ⊢ u / v ⟶* X / β
		
		  predict : {u v : T *} {X Y : N} {α β : (N ∣ T) *} ->
		    CFG.rules G ∋ (Y , α) ->
		    G ⊢ u / v ⟶* X / l Y ∷ β ->
		      G ⊢ v / v ⟶* Y / α
		
		  complet : {u v w : T *} {X Y : N} {β : (N ∣ T) *} ->
		    G ⊢ u / v ⟶* X / l Y ∷ β ->
		    G ⊢ v / w ⟶* Y / ε ->
		      G ⊢ u / w ⟶* X / β
		
	\end{code}

	\begin{code}

		sound : ∀ {u v w X β} {G : CFG} ->
		  G ⊢ u / v ⟶* X / β ->
		  G ⊢ v / w ∈ β ->
		    G ⊢ u / w ∈ l X ∷ ε
		sound initial b = b
		sound (scanner a) b = sound a (term b)
		sound (predict x a) b = nont x b
		sound (complet a a₁) b =
		  let x₁ = sound a₁ empt in
		  let x₂ = conc x₁ b in
		  sound a x₂

	\end{code}

	\begin{code}
		
		complete : ∀ {u v w X α} {G : CFG} ->
		  G ⊢ u / v ⟶* X / α ->
		  G ⊢ v / w ∈ α ->
		    G ⊢ u / w ⟶* X / ε
		complete a empt = a
		complete a (conc (conc b empt) b₁) = complete a (conc b b₁)
		complete a (conc (nont x b) b₁) =
		  let x₁ = predict x a in
		  let x₂ = complete x₁ b in
		  let x₃ = complet a x₂ in
		  complete x₃ b₁
		complete a (term b) = complete (scanner a) b
		complete a (nont x b) = complet a (complete (predict x a) b)

	\end{code}
	
	\begin{code}

		record Item (n : ℕ) : Set where
		  constructor _∘_↦_∘_
		  field
		    Y : N
		    j : ℕ
		    α β : (N ∣ T) *
		    .{χ} : CFG.rules G ∋ (Y , α ++ β)
		    .{ω} : j ≤ n

	\end{code}

	\begin{code}

		data WSet : ℕ -> T * -> Set where
		  start :
		    (v : T *) ->
		    (rs : Item zero * ) ->
		    WSet zero v
		
		  step : {a : T} {v : T *} {n : ℕ} ->
		    (w : WSet n (a ∷ v)) ->
		    (rs : Item (suc n) * ) ->
		    WSet (suc n) v

	\end{code}
	
	\begin{code}

		in-all : ∀ {j} -> (i : Item j) -> all-rules j ∋ i

	\end{code}

	\begin{code}

		step-w : ∀ {n a v} ->
		  WSet n (a ∷ v) ->
		  WSet (suc n) v
		step-w {a = a} {v = v} w = scanner-w a v (pred-comp-w w)
	
	\end{code}
